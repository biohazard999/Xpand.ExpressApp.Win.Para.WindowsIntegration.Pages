{"name":"Xpand.ExpressApp.Win.Para.WindowsIntegration","tagline":"","body":"Xpand.ExpressApp.Win.Para.WindowsIntegration\r\n============================================\r\n\r\nDeeper Windows Integration Features to XAF/Xpand\r\n\r\n\r\n## The WindowsIntegrationWindowsFormsModule ##\r\n\r\nThis Module allows you to integrate the [TaskbarAssistent](http://documentation.devexpress.com/#WindowsForms/clsDevExpressUtilsTaskbarTaskbarAssistanttopic \"TaskbarAssistent Component\") into XAF.\r\n\r\n### Installation ###\r\n\r\nSimple grab via nuget or download the source and rebuild it. If you build it from scratch you need to specify a key for strong naming.\r\n\r\n    Install-Package Xpand.ExpressApp.Win.Para.WindowsIntegration\r\n\r\n\r\n### Getting started ###\r\n\r\nIntegrate the `WindowsIntegrationWindowsFormsModule` like you would do with any Module.\r\nThis is a WindowsForms only Module.\r\n\r\nRebuild your project and you will see 2 additional nodes in the Options section:\r\n\r\n![](http://i.imgur.com/vur7hpM.png)\r\n\r\nThe `TaskbarJumpListOptions` node allows you to specify `JumplistCategories` and `JumplistItems`. \r\n\r\n### Jumplists ###\r\n\r\nSet the `EnableJumplist` option to `True` and specify a argument name that will be used to launch your application with command line arguments.\r\n\r\n![](http://i.imgur.com/EsCmOa4.png)\r\n\r\n\r\n> Note if you only like to launch external applications you can skip the `NavigationItemJumplistArgumentName`\r\n> The `NavigationItemJumplistArgumentName` should end with a **colon**.\r\n\r\nYou see two nodes:\r\n\r\n\r\n1. The `CustomCategories` node: This allows you to specify custom categories with `JumpItems` in it.\r\n2. The `TasksCategory` is the default category provided by windows.\r\n\r\n\r\n![](http://i.imgur.com/CjcAtQ1.png)\r\n\r\nCurrently there are 3 types of `JumpListItems`:\r\n\r\n1. The `TaskbarJumplistJumpItemLaunch` allows you to specify any program that you'd like to launch. You can provide arguments and a `WorkingDirectory`.\r\n2. The `TaskbarJumplistJumpItemNavigationItem` allows you to specify a `NavigationItem` the user can select from the the Jumplist.\r\n3. The `TaskbarJumplistSeperatorItem` is a simple seperator that draws a horizontal line.\r\n\r\n![](http://i.imgur.com/sJtdh5W.png)\r\n\r\n\r\n#### TaskbarJumplistJumpItemLaunch ####\r\n![](http://i.imgur.com/QSAoYJY.png)\r\n\r\nYou can currently specify:\r\n\r\n- `PathToLaunch`: The program you like to launch\r\n- `Arguments`: The arguments that are passed to the application\r\n- `WorkingDirectory`: Specifies the folder in which the program is launched\r\n- `ImageName`: An [ImageName](#Images) to provide an icon for the JumpListItem\r\n- `Caption`: The Text that is displayed to the user\r\n- `Index`: The order of the JumpListItem\r\n- `Id`: The Id of the item\r\n\r\n#### TaskbarJumplistJumpItemNavigationItem ####\r\n![](http://i.imgur.com/q4XDmM7.png)\r\n\r\nYou can currently specify:\r\n\r\n- `NavigationItem`: Specifies the NavigationItem that should be shown\r\n- `UseProtocolIfAvailable`: Uses the protocol handler if available\r\n- `ImageName`: An [ImageName](#Images) to provide an icon for the JumpListItem \r\n- `Caption`: The Text that is displayed to the user\r\n- `Index`: The order of the JumpListItem\r\n- `Id`: The Id of the item\r\n\r\n#### TaskbarJumplistSeperatorItem ####\r\n![](http://i.imgur.com/zOAhFkd.png)\r\n\r\nYou can currently specify:\r\n\r\n- `Index`: The order of the JumpListItem\r\n- `Id`: The Id of the item\r\n\r\n\r\n#### Custom Categories ####\r\n![](http://i.imgur.com/4pUwdBX.png)\r\n\r\n![](http://i.imgur.com/bVMs33r.png)\r\n\r\n\r\nYou can currently specify:\r\n\r\n- `Caption`: The caption of the Category\r\n- `Index`: The order of the JumpListItem\r\n- `Id`: The Id of the item\r\n\r\nAdding new items is exact the same as for the `TasksCategory`.\r\n\r\n\r\n### Bootstrapping code for NavigationItemJumplistItems ###\r\n\r\n    static class Program\r\n    {\r\n        private static WinApplication _Application;\r\n\r\n        /// <summary>\r\n        /// The main entry point for the application.\r\n        /// </summary>\r\n        [STAThread]\r\n        static void Main()\r\n        {\r\n            var assemblyName = typeof(Program).Assembly.GetName();\r\n            var mutexName = assemblyName.Name + \"_\" + assemblyName.Version.ToString(3);\r\n\r\n    #if DEBUG\r\n            mutexName += \"_Debug\";\r\n    #endif\r\n            using (var instance = new SingleInstance(mutexName))\r\n            {\r\n                if (instance.IsFirstInstance)\r\n                {\r\n                    instance.ArgumentsReceived += WindowsIntegrationWindowsFormsModule.InstanceOnArgumentsReceived;\r\n\r\n                    instance.ListenForArgumentsFromSuccessiveInstances();\r\n\r\nSpecify a mutex name. This is an ordinary string, my experiance has shown that a combination of the assemblyName combined with the version of the application and a debug constant works very well for the most scenarios.\r\n\r\nCreate an instance of the `SingleInstance` class that manages our application instances.\r\nCheck if this is the first instance launched, attach the `ArgumentsReceived` event handler to the `WindowsIntegrationWindowsFormsModule.InstanceOnArgumentsReceived` method and call the `ListenForArgumentsFromSuccessiveInstances` method to listen for new arguments on the `NamedPipe`.\r\n\r\n\r\nCreate your application as you always would:\r\n\r\n    Application.EnableVisualStyles();\r\n    Application.SetCompatibleTextRenderingDefault(false);\r\n\r\n    _Application = new WinApplication\r\n    {\r\n        ApplicationName = assemblyName.Name,\r\n        SplashScreen = new DevExpress.ExpressApp.Win.Utils.DXSplashScreen()\r\n    };\r\n\r\n    _Application.CreateCustomObjectSpaceProvider += (sender, args) =>\r\n    {\r\n        args.ObjectSpaceProvider = new XPObjectSpaceProvider(new ConnectionStringDataStoreProvider(args.ConnectionString));\r\n    };\r\n\r\n    _Application.DatabaseVersionMismatch += (sender, args) =>\r\n    {\r\n        args.Updater.Update();\r\n        args.Handled = true;\r\n    };\r\n\r\n    _Application.Modules.Add(new SystemModule());\r\n    _Application.Modules.Add(new SystemWindowsFormsModule());\r\n    _Application.Modules.Add(new WindowsIntegrationWindowsFormsModule());\r\n    _Application.Modules.Add(new DemoCenterModule());\r\n    _Application.Modules.Add(new DemoCenterWindowsFormsModule());\r\n\r\n**Before** you start the application make sure you pass the `WinApplication` instance to the `WindowsIntegrationWindowsFormsModule.TaskbarApplication` propety:\r\n\r\n    WindowsIntegrationWindowsFormsModule.TaskbarApplication = _Application;\r\n\r\nThan setup and launch your application\r\n\r\n    InMemoryDataStoreProvider.Register();\r\n    _Application.ConnectionString = InMemoryDataStoreProvider.ConnectionString;\r\n\r\n    try\r\n    {\r\n        _Application.Setup();\r\n\r\n        _Application.Start();\r\n    }\r\n    catch (Exception e)\r\n    {\r\n        _Application.HandleException(e);\r\n    }\r\n\r\nIf the application is **not** the first instance pass the arguments to the first instance:\r\n\r\n    }\r\n    else\r\n    {\r\n        instance.PassArgumentsToFirstInstance();\r\n    }\r\n\r\nThe whole bootstrapper now should look like this:\r\n\r\n    using System;\r\n    using System.Configuration;\r\n    using System.Windows.Forms;\r\n    using DevExpress.ExpressApp.SystemModule;\r\n    using DevExpress.ExpressApp.Win;\r\n    using DevExpress.ExpressApp.Win.SystemModule;\r\n    using DevExpress.ExpressApp.Xpo;\r\n    using Xpand.Demo.Para.DemoCenter.Module.Win;\r\n    using Xpand.ExpressApp.Win.Para.WindowsIntegration;\r\n    \r\n    namespace Xpand.Demo.Para.DemoCenter.Win\r\n    {\r\n        static class Program\r\n        {\r\n            private static WinApplication _Application;\r\n    \r\n            /// <summary>\r\n            /// The main entry point for the application.\r\n            /// </summary>\r\n            [STAThread]\r\n            static void Main()\r\n            {\r\n                var assemblyName = typeof(Program).Assembly.GetName();\r\n                var mutexName = assemblyName.Name + \"_\" + assemblyName.Version.ToString(3);\r\n    \r\n    #if DEBUG\r\n                mutexName += \"_Debug\";\r\n    #endif\r\n                using (var instance = new SingleInstance(mutexName))\r\n                {\r\n                    if (instance.IsFirstInstance)\r\n                    {\r\n                        instance.ArgumentsReceived += WindowsIntegrationWindowsFormsModule.InstanceOnArgumentsReceived;\r\n    \r\n                        instance.ListenForArgumentsFromSuccessiveInstances();\r\n    \r\n                        Application.EnableVisualStyles();\r\n                        Application.SetCompatibleTextRenderingDefault(false);\r\n    \r\n                        _Application = new WinApplication\r\n                        {\r\n                            ApplicationName = assemblyName.Name,\r\n                            SplashScreen = new DevExpress.ExpressApp.Win.Utils.DXSplashScreen()\r\n                        };\r\n    \r\n                        _Application.CreateCustomObjectSpaceProvider += (sender, args) =>\r\n                        {\r\n                            args.ObjectSpaceProvider = new XPObjectSpaceProvider(new ConnectionStringDataStoreProvider(args.ConnectionString));\r\n                        };\r\n    \r\n                        _Application.DatabaseVersionMismatch += (sender, args) =>\r\n                        {\r\n                            args.Updater.Update();\r\n                            args.Handled = true;\r\n                        };\r\n    \r\n                        _Application.Modules.Add(new SystemModule());\r\n                        _Application.Modules.Add(new SystemWindowsFormsModule());\r\n                        _Application.Modules.Add(new WindowsIntegrationWindowsFormsModule());\r\n                        _Application.Modules.Add(new DemoCenterModule());\r\n                        _Application.Modules.Add(new DemoCenterWindowsFormsModule());\r\n    \r\n                        WindowsIntegrationWindowsFormsModule.TaskbarApplication = _Application;\r\n    \r\n                        InMemoryDataStoreProvider.Register();\r\n                        _Application.ConnectionString = InMemoryDataStoreProvider.ConnectionString;\r\n    \r\n                        try\r\n                        {\r\n                            _Application.Setup();\r\n    \r\n                            _Application.Start();\r\n                        }\r\n                        catch (Exception e)\r\n                        {\r\n                            _Application.HandleException(e);\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        instance.PassArgumentsToFirstInstance();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\nThat's it!\r\n\r\n### Custom Protocols ###\r\n\r\nThe custom protocol options allow you to launch your application via an custom protocol. This can be handy if you like to send a link to another workstation to open the application with a specific window. You can think about this like a normal hyperlink but this works for your machine.\r\n\r\nSelect the CustomProtocolOptions node:\r\n\r\n![](http://i.imgur.com/rgCkl9u.png)\r\n\r\nSet the `EnableProtocols` to `True` and specify a `ProtolName`. You see a demo of the protocol under the `ProtocolHandler` node.\r\n\r\nYou can currently specify:\r\n\r\n- `AutoRegisterProtols`: This will write the needed registry keys automatically, when the application launches\r\n- `EnableProtocols`: This en/disables the whole logic for protocol handlers\r\n- `ProtocolDescription`: This is a hint in the registry what this protocol does\r\n- `ProtoclName`: The name of your protocol. This should not start with a number, dashes are allowed. See more under the [microsoft documentation](http://msdn.microsoft.com/en-us/library/aa767914(VS.85).aspx)\r\n\r\n\r\n### Images ###\r\n\r\nThe Images will automatically be compiled into a new dll (based on `WinApplication.UserModelDifferenceFilePath`)\r\nYou can specify the name of the generated assembly via the `Options.AutomaticImageAssemblyName` parameter. The default leads to `JumplistImages.dll`.\r\n\r\nThis is necessary because windows needs a `NativeResource` assembly. This will be full automatically generated for all images used by your `JumplistItems`.\r\n\r\n> If you launch your application, windows is sometimes caching the icons in the jumplists, so you may not see the actual image you set. After a reboot (or a windows logon/logoff) your application icon should be updated.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}